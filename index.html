<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pengecek Isomorfisme Graf Dinamis</title>
    <!-- Memuat Tailwind CSS untuk styling --><script src="https://cdn.tailwindcss.com"></script>
    <!-- Menggunakan font Inter --><link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* bg-gray-100 */
        }
        canvas {
            background-color: #ffffff;
            border-radius: 0.5rem; /* rounded-lg */
            border: 1px solid #d1d5db; /* border-gray-300 */
            cursor: pointer; /* Menandakan bisa di-klik */
            /* --- PERBAIKAN RESPONSIVE --- */
            @apply w-full h-auto; /* Membuat kanvas mengecil di HP */
        }
        .btn {
            @apply inline-block px-6 py-3 bg-blue-600 text-white font-medium text-sm leading-tight rounded-lg shadow-md hover:bg-blue-700 hover:shadow-lg focus:bg-blue-700 focus:shadow-lg focus:outline-none focus:ring-0 active:bg-blue-800 active:shadow-lg transition duration-150 ease-in-out;
        }
        .btn-secondary {
            @apply inline-block px-5 py-2 bg-gray-600 text-white font-medium text-xs leading-tight rounded-lg shadow-md hover:bg-gray-700 hover:shadow-lg focus:bg-gray-700 focus:shadow-lg focus:outline-none focus:ring-0 active:bg-gray-800 active:shadow-lg transition duration-150 ease-in-out;
        }
        #resultMessage {
            @apply mt-6 p-4 rounded-lg text-center font-medium;
        }
        .result-success {
            @apply bg-green-100 text-green-800;
        }
        .result-error {
            @apply bg-red-100 text-red-800;
        }
        .result-warning {
            @apply bg-yellow-100 text-yellow-800;
        }
        .result-info {
            @apply bg-blue-100 text-blue-800;
        }

        .matrix-table {
            /* --- DIPERBARUI: Dibuat lebih kecil dan rapi --- */
            @apply table-auto border-collapse border border-gray-400 text-xs text-center mx-auto;
        }
        .matrix-table th, .matrix-table td {
            @apply border border-gray-300 p-1;
            /* --- BARU: Ukuran kotak dibuat konsisten --- */
            min-width: 1.5rem; 
            height: 1.5rem;
        }
        .matrix-table th {
            @apply bg-gray-100 font-semibold;
        }

        .setup-box {
            @apply mb-8 p-4 bg-white border border-gray-200 rounded-lg shadow flex flex-col sm:flex-row items-center justify-center space-y-2 sm:space-y-0 sm:space-x-4;
        }
        
        .instructions {
            @apply text-center text-sm text-gray-600 p-3 bg-gray-50 rounded-md;
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <!-- Container dibuat lebih sempit (max-w-5xl) agar lebih rapi untuk 1 kolom -->
    <div class="max-w-5xl mx-auto bg-white p-6 md:p-10 rounded-xl shadow-lg">

        <!-- PERBAIKAN RESPONSIVE: Judul dibuat lebih kecil di HP (text-2xl) dan besar di laptop (sm:text-3xl) -->
        <h1 class="text-2xl sm:text-3xl font-bold text-center text-gray-800 mb-2">Pengecek Isomorfisme Graf Dinamis</h1>
        <p class="text-center text-gray-600 mb-6">Tentukan jumlah simpul, gambar sisi, geser simpul, lalu bandingkan.</p>

        <!-- Bagian Setup Jumlah Simpul -->
        <div class="setup-box">
            <label for="nodeCount" class="text-sm font-medium text-gray-700">Jumlah Simpul:</label>
            <input type="number" id="nodeCount" value="6" min="1" max="200" class="w-24 p-2 border border-gray-300 rounded-md text-center text-sm">
            
            <label for="layoutShape" class="text-sm font-medium text-gray-700 sm:ml-4">Bentuk:</label>
            <select id="layoutShape" class="p-2 border border-gray-300 rounded-md text-sm">
                <option value="otomatis" selected>Otomatis (Default)</option>
                <option value="lingkaran">Lingkaran</option>
                <option value="grid">Grid</option>
                <option value="garis">Garis</option>
                <option value="spiral">Spiral</option>
                <option value="acak">Acak</option>
            </select>
            
            <button id="createGraphButton" class="btn-secondary">Buat Kerangka Graf</button>
            
            <!-- BARU: Tombol Toggle untuk Mode Geser (Drag) -->
            <button id="toggleDragButton" class="inline-block px-5 py-2 bg-blue-600 text-white font-medium text-xs leading-tight rounded-lg shadow-md hover:bg-blue-700 focus:bg-blue-700 focus:shadow-lg focus:outline-none focus:ring-0 active:bg-blue-800 active:shadow-lg transition duration-150 ease-in-out">Mode Geser: ON</button>
        </div>

        <div class="grid grid-cols-1 gap-8">
            <!-- Kolom Graf G --><div class="p-4 border border-gray-200 rounded-lg">
                <h3 class="text-xl font-semibold text-center mb-3">Graf G</h3>
                <canvas id="graphGCanvas" width="600" height="500" class="mx-auto"></canvas>
                <div id="inputsG" class="mt-4">
                    <!-- BARU: Instruksi diperbarui -->
                    <p class="instructions">
                        <strong>Geser:</strong> Tekan-tahan-geser simpul untuk memindahkannya.
                        <br>
                        <strong>Gambar Sisi:</strong> Klik simpul pertama, lalu klik simpul kedua.
                    </p>
                </div>
                <div id="propsG" class="mt-4 text-sm text-gray-700"></div>

                <!-- ==================================================== -->
                <!-- --- BARU: Kontainer Matriks Adjacency G (Slide 2) --- -->
                <!-- ==================================================== -->
                <div class="mt-4">
                    <h4 class="text-md font-semibold mb-2 text-center">Matriks Adjacency (A<sub>G</sub>)</h4>
                    <div id="matrixContainerG" class="overflow-x-auto p-1">
                        <!-- Tabel matriks G akan di-render di sini oleh JavaScript -->
                    </div>
                </div>
                <!-- ==================================================== -->

            </div>
            
            <!-- Kolom Graf H --><div class="p-4 border border-gray-200 rounded-lg">
                <h3 class="text-xl font-semibold text-center mb-3">Graf H</h3>
                <canvas id="graphHCanvas" width="600" height="500" class="mx-auto"></canvas>
                <div id="inputsH" class="mt-4">
                        <!-- BARU: Instruksi diperbarui -->
                    <p class="instructions">
                        <strong>Geser:</strong> Tekan-tahan-geser simpul untuk memindahkannya.
                        <br>
                        <strong>Gambar Sisi:</strong> Klik simpul pertama, lalu klik simpul kedua.
                    </p>
                </div>
                <div id="propsH" class="mt-4 text-sm text-gray-700"></div>
                
                <!-- ==================================================== -->
                <!-- --- BARU: Kontainer Matriks Adjacency H (Slide 2) --- -->
                <!-- ==================================================== -->
                <div class="mt-4">
                    <h4 class="text-md font-semibold mb-2 text-center">Matriks Adjacency (A<sub>H</sub>)</h4>
                    <div id="matrixContainerH" class="overflow-x-auto p-1">
                        <!-- Tabel matriks H akan di-render di sini oleh JavaScript -->
                    </div>
                </div>
                <!-- ==================================================== -->

            </div>
        </div>

        <div class="text-center mt-8">
            <button id="checkIsomorphismButton" class="btn">Bandingkan Derajat & Cek Isomorfisme</button>
        </div>
        
        <div id="resultMessage" class="hidden"></div>

        <div id="loadingIndicator" class="hidden mt-4 text-center">
            <p class="text-blue-600 font-medium">Menjalankan pengecekan isomorfisme penuh... Ini mungkin perlu beberapa detik...</p>
        </div>
    </div>

    <script>
        // Variabel global untuk menyimpan state graf
        let currentGraphG = { nodes: [], edges: {} };
        let currentGraphH = { nodes: [], edges: {} };
        let ctxG, ctxH;

        // --- BARU: Variabel State untuk Drag-and-Drop ---
        let selectedNodeG = null; // Untuk 'click'
        let draggedNodeG = null; // Untuk 'drag'
        let isDraggingG = false;
        let selectedNodeH = null;
        let draggedNodeH = null;
        let isDraggingH = false;
        let dragStartX, dragStartY;
        // --- AKHIR VARIABEL BARU ---

        // --- BARU: Variabel Global untuk Toggle Drag ---
        let isDragModeEnabled = true; // Default ON

        const FULL_CHECK_LIMIT = 15;

        // --- BARU: Helper untuk mendapatkan posisi mouse relatif ---
        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (evt.clientX - rect.left) * scaleX,
                y: (evt.clientY - rect.top) * scaleY
            };
        }

        function drawNodes(ctx, graph, selectedNodeId) {
            const n = graph.nodes.length;
            const nodeRadius = (n > 70) ? 3 : (n > 40) ? 5 : 8;
            const fontSize = (n > 100) ? 7 : (n > 50) ? 8 : 14;
            const degreeFontSize = (n > 100) ? 8 : (n > 50) ? 9 : 12;

             // HANYA gambar simpul dan label/derajat
            graph.nodes.forEach(node => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, nodeRadius, 0, 2 * Math.PI);
                ctx.fillStyle = '#374151';
                ctx.fill();

                if (node.id === selectedNodeId) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, nodeRadius + 3, 0, 2 * Math.PI);
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                ctx.fillStyle = '#111827';
                ctx.font = `${fontSize}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(node.label, node.x, node.y - (nodeRadius + 2)); 

                if (n <= 100) {
                    ctx.font = `${degreeFontSize}px Inter`;
                    ctx.textBaseline = 'top';
                    ctx.fillStyle = '#4b5563';
                    ctx.fillText(`(${node.degree})`, node.x, node.y + (nodeRadius + 2));
                }
            });
        }

        // --- BARU: Fungsi untuk update tabel matriks adjacency ---
        function updateAdjacencyMatrix(graphId) {
            const isG = graphId === 'G';
            const graph = isG ? currentGraphG : currentGraphH;
            const containerId = isG ? 'matrixContainerG' : 'matrixContainerH';
            const container = document.getElementById(containerId);

            if (!graph.nodes || graph.nodes.length === 0) {
                container.innerHTML = '<p class="text-xs text-center text-gray-500">Buat kerangka graf untuk melihat matriks.</p>';
                return;
            }

            // Memanggil fungsi yang sudah ada untuk membangun data matriks
            const matrixData = buildAdjacencyMatrix(graph.nodes, graph.edges);
            // Memanggil fungsi yang sudah ada untuk format HTML
            const matrixHTML = formatMatrixAsHTML(matrixData);
            
            container.innerHTML = matrixHTML;

            // --- KUNCI OPTIMASI 1 ---
            // Simpan pemetaan ID ke index agar kita bisa update sel nanti
            if (isG) {
                currentGraphG.nodeIdToIndex = matrixData.nodeIdToIndex;
            } else {
                currentGraphH.nodeIdToIndex = matrixData.nodeIdToIndex;
            }
        }

        // --- KUNCI OPTIMASI 2: Fungsi BARU untuk update sel individual (INSTAN) ---
        function updateMatrixCell(graphId, node1Id, node2Id, newValue) {
            const isG = graphId === 'G';
            const graph = isG ? currentGraphG : currentGraphH;
            const tableId = isG ? 'matrixTableG' : 'matrixTableH';
            const table = document.getElementById(tableId);

            // Jika tabel belum ada atau map belum siap, batalkan.
            if (!table || !graph.nodeIdToIndex) return;

            const i = graph.nodeIdToIndex.get(node1Id);
            const j = graph.nodeIdToIndex.get(node2Id);

            if (i === undefined || j === undefined) return; // Harusnya tidak terjadi

            // Update sel [i][j] dan [j][i]
            // +1 karena ada baris/kolom header
            try {
                if (table.rows[i + 1] && table.rows[i + 1].cells[j + 1]) {
                    table.rows[i + 1].cells[j + 1].textContent = newValue;
                }
                if (table.rows[j + 1] && table.rows[j + 1].cells[i + 1]) {
                    table.rows[j + 1].cells[i + 1].textContent = newValue;
                }
            } catch (e) {
                console.error("Gagal update sel matriks:", e);
                // Jika gagal, fallback ke rebuild total (meski lambat)
                // updateAdjacencyMatrix(graphId);
            }
        }

        // --- DIPERBAIKI: Penambahan fungsi drawCanvasOnly ---
        // --- BARU: Versi ringan dari redrawGraphFromEdges HANYA untuk kanvas ---
        // --- Ini dipanggil selama drag agar tidak nge-lag ---
        function drawCanvasOnly(graphId) {
            const isG = graphId === 'G';
            const ctx = isG ? ctxG : ctxH;
            const graph = isG ? currentGraphG : currentGraphH;
            const selectedNodeId = isG ? selectedNodeG?.id : selectedNodeH?.id;
            const nodeMap = new Map(graph.nodes.map(n => [n.id, n]));

            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // 1. Gambar semua SISI (Tanpa hitung ulang derajat)
            ctx.strokeStyle = '#374151'; 
            ctx.lineWidth = (graph.nodes.length > 50) ? 1 : 2;
            for (const edgeKey in graph.edges) {
                if (graph.edges[edgeKey]) {
                    const [id1, id2] = edgeKey.split('-');
                    const node1 = nodeMap.get(id1);
                    const node2 = nodeMap.get(id2);
                    if (node1 && node2) {
                        ctx.beginPath();
                        ctx.moveTo(node1.x, node1.y);
                        ctx.lineTo(node2.x, node2.y);
                        ctx.stroke();
                    }
                }
            }

            // 2. Gambar semua SIMPUL
            drawNodes(ctx, graph, selectedNodeId);
        }

        // --- DIPERBAIKI: Penambahan fungsi animationLoop ---
        // --- BARU: Loop animasi untuk drag agar mulus ---
        function animationLoop() {
            // Cek apakah ada yang di-drag
            // Loop ini aman karena isDraggingG/H only bisa true jika mode drag ON
            if (isDraggingG && draggedNodeG) {
                drawCanvasOnly('G'); // Gambar kanvas G (ringan)
            }
            if (isDraggingH && draggedNodeH) {
                drawCanvasOnly('H'); // Gambar kanvas H (ringan)
            }

            // Minta frame berikutnya
            requestAnimationFrame(animationLoop);
        }

        /* --- PERBAIKAN: Menghapus sisa fungsi 'redrawGraphFromEdges' yang rusak --- */
        /*
        function redrawGraphFromEdges(graphId) {
        // --- HAPUS: Fungsi redrawGraphFromEdges() yang lama dihapus ---
        // (Logikanya akan dipecah)
        }
        */
        /* --- AKHIR DARI BLOK YANG DIHAPUS --- */

        // --- BARU: Fungsi untuk menghitung ulang semua properti dari awal ---
        // Ini HANYA dipanggil saat createGraphSkeletons
        function recalculateAllProperties(graphId) {
            const isG = graphId === 'G';
            const graph = isG ? currentGraphG : currentGraphH;
            const propElId = isG ? 'propsG' : 'propsH';
            const nodeMap = new Map(graph.nodes.map(n => [n.id, n]));

            // 1. Hitung ulang semua derajat
            for (const node of graph.nodes) {
                node.degree = 0;
            }
            for (const edgeKey in graph.edges) {
                if (graph.edges[edgeKey]) {
                    const [id1, id2] = edgeKey.split('-');
                    const node1 = nodeMap.get(id1);
                    const node2 = nodeMap.get(id2);
                    if (node1) node1.degree++;
                    if (node2) node2.degree++;
                }
            }
            
            // 2. Update properti (derajat, dll)
            displayProperties(propElId, graph.nodes, graph.edges);
        }

        function getDegreeSequence(graphNodes) {
            return graphNodes.map(node => parseInt(node.degree, 10) || 0).sort((a, b) => a - b);
        }
        
        function displayProperties(elementId, nodes, edges) {
            const el = document.getElementById(elementId);
            if (!nodes || nodes.length === 0) {
                el.innerHTML = '';
                return;
            }
            const degreeSequence = getDegreeSequence(nodes);
            const edgeCount = Object.values(edges).filter(Boolean).length;

            let degreesList = '<ul>';
            nodes.forEach(node => {
                degreesList += `<li>deg(${node.label}) = ${node.degree}</li>`;
            });
            degreesList += '</ul>';
            
            const listHeight = (nodes.length > 20) ? 'max-h-40' : 'max-h-24';

            el.innerHTML = `
                <p><strong>Jumlah Simpul:</strong> ${nodes.length}</p>
                <p><strong>Jumlah Sisi:</strong> ${edgeCount}</p>
                <p><strong>Urutan Derajat (sorted):</strong> ${degreeSequence.join(', ')}</p>
                <div class="mt-2 text-xs ${listHeight} overflow-y-auto border-t pt-2">
                    <p><strong>Derajat Individual:</strong></p>
                    ${degreesList}
                </div>
            `;
        }

        function getClickedNode(x, y, nodes) {
            const n = nodes.length;
            const nodeRadius = (n > 70) ? 3 : (n > 40) ? 5 : 8;
            // Area klik/drag dibuat lebih besar
            const hitRadius = nodeRadius + 8; 

            // Loop dari belakang agar simpul di atas terdeteksi dulu
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                const dx = x - node.x;
                const dy = y - node.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < hitRadius) {
                    return node;
                }
            }
            return null;
        }

        function getEdgeKey(node1, node2) {
            // Urutkan berdasarkan ID numerik (misal 'u10' > 'u2')
            const id1_num = parseInt(node1.id.match(/\d+/)[0]);
            const id2_num = parseInt(node2.id.match(/\d+/)[0]);
            
            if (id1_num < id2_num) {
                return `${node1.id}-${node2.id}`;
            } else {
                return `${node2.id}-${node1.id}`;
            }
        }
        
        // --- BARU: Mengganti setupCanvasClickListener ---
        // --- dengan setupCanvasInteractions ---
        function setupCanvasInteractions(graphId, canvas) {
            
            canvas.addEventListener('mousedown', (e) => {
                const isG = (graphId === 'G');
                const graph = isG ? currentGraphG : currentGraphH;
                const mousePos = getMousePos(canvas, e);
                const clickedNode = getClickedNode(mousePos.x, mousePos.y, graph.nodes);

                if (clickedNode) {
                    if (isG) {
                        draggedNodeG = clickedNode;
                        isDraggingG = false; // Belum tahu ini drag atau click
                    } else {
                        draggedNodeH = clickedNode;
                        isDraggingH = false;
                    }
                    dragStartX = mousePos.x;
                    dragStartY = mousePos.y;
                }
            });

            // ==========================================================
            // --- INI ADALAH FUNGSI BARU YANG DITAMBAHKAN ---
            // ==========================================================
            canvas.addEventListener('mousemove', (e) => {
                const isG = (graphId === 'G');
                let isDragging = isG ? isDraggingG : isDraggingH;
                let draggedNode = isG ? draggedNodeG : draggedNodeH;

                // 1. Cek jika mode geser OFF, atau tidak ada simpul yang dipegang
                if (!isDragModeEnabled || !draggedNode) {
                    return;
                }

                // 2. Dapatkan posisi mouse
                const mousePos = getMousePos(canvas, e);
                
                // 3. Tentukan apakah ini 'drag' atau 'click'
                // Kita beri jarak minimal 5px sebelum dianggap 'drag'
                const dragThreshold = 5;
                if (!isDragging && (Math.abs(mousePos.x - dragStartX) > dragThreshold || Math.abs(mousePos.y - dragStartY) > dragThreshold)) {
                    // Jika melebihi threshold, ini resmi 'drag'
                    if (isG) {
                        isDraggingG = true;
                        isDragging = true; // Update variabel lokal
                    } else {
                        isDraggingH = true;
                        isDragging = true; // Update variabel lokal
                    }
                }

                // 4. Jika sedang dalam mode 'drag', update koordinat simpul
                if (isDragging) {
                    const graph = isG ? currentGraphG : currentGraphH;
                    const n = graph.nodes.length;
                    const nodeRadius = (n > 70) ? 3 : (n > 40) ? 5 : 8;

                    // Jaga agar simpul tidak keluar dari batas canvas
                    draggedNode.x = Math.max(nodeRadius, Math.min(canvas.width - nodeRadius, mousePos.x));
                    draggedNode.y = Math.max(nodeRadius, Math.min(canvas.height - nodeRadius, mousePos.y));
                    
                    // Kita TIDAK perlu memanggil drawCanvasOnly() di sini.
                    // animationLoop() akan menanganinya secara otomatis dan lebih mulus.
                }
            });
            // ==========================================================
            // --- AKHIR DARI FUNGSI BARU ---
            // ==========================================================


            // --- DIPERBAIKI: Logika 'mouseup' dirombak total untuk performa ---
            canvas.addEventListener('mouseup', (e) => {
                const isG = (graphId === 'G');
                const isDragging = isG ? isDraggingG : isDraggingH;
                let draggedNode = isG ? draggedNodeG : draggedNodeH;

                // --- PERBAIKAN: Variabel untuk menangani scope ---
                let edgeKey = null;
                let selectedNodeForEdge = null;
                let clickedNodeForEdge = null;
                let didEdgeChange = false;
                // --- AKHIR PERBAIKAN SCOPE ---

                if (!draggedNode) return; // mouseup tanpa mousedown di simpul

                // Simpan node yg di-klik sebelum di-reset
                clickedNodeForEdge = draggedNode; 

                // Reset state drag SEGERA
                if (isG) {
                    draggedNodeG = null;
                    isDraggingG = false;
                } else {
                    draggedNodeH = null;
                    isDraggingH = false;
                }

                if (!isDragging) {
                    // --- Jika BUKAN drag, maka ini adalah CLICK ---
                    
                    // --- PENTING: Jika mode drag OFF, kita TIDAK boleh membuat sisi ---
                    if (isDragModeEnabled === false) {
                        // Jika mode drag OFF, anggap saja ini 'batal pilih'
                        if (isG) selectedNodeG = null; else selectedNodeH = null;
                        drawCanvasOnly(graphId); // Gambar ulang untuk hilangkan highlight kuning
                        return;
                    }
                    
                    let selectedNode = isG ? selectedNodeG : selectedNodeH;

                    if (!selectedNode) {
                        // Click 1: Select
                        if (isG) selectedNodeG = clickedNodeForEdge; else selectedNodeH = clickedNodeForEdge;
                    } else {
                        // Click 2
                        if (clickedNodeForEdge.id === selectedNode.id) {
                            // Klik simpul yang sama: Deselect
                            if (isG) selectedNodeG = null; else selectedNodeH = null;
                        } else {
                            // Klik simpul berbeda: Buat/Hapus Sisi
                            edgeKey = getEdgeKey(selectedNode, clickedNodeForEdge);
                            
                            // --- PERBAIKAN: Simpan node untuk diakses nanti ---
                            selectedNodeForEdge = selectedNode;
                            didEdgeChange = true;
                            // --- AKHIR PERBAIKAN ---

                            if (isG) selectedNodeG = null; else selectedNodeH = null;
                        }
                    }
                }
                // Jika isDragging == true, kita hanya melepas (state sudah di-reset)
                
                // --- LOGIKA UTAMA OPTIMASI ---
                
                if (didEdgeChange) {
                    // --- Terjadi perubahan sisi (Tambah/Hapus) ---
                    const graph = isG ? currentGraphG : currentGraphH;
                    const propElId = isG ? 'propsG' : 'propsH';
                    let newValue;

                    // --- KUNCI OPTIMASI 3: Update derajat secara instan (O(1)) ---
                    if (graph.edges[edgeKey]) { // Sisi sudah ada -> HAPUS
                        graph.edges[edgeKey] = false;
                        selectedNodeForEdge.degree--;
                        clickedNodeForEdge.degree--;
                        newValue = 0;
                    } else { // Sisi belum ada -> TAMBAH
                        graph.edges[edgeKey] = true;
                        selectedNodeForEdge.degree++;
                        clickedNodeForEdge.degree++;
                        newValue = 1;
                    }

                    // --- KUNCI OPTIMASI 4: Update teks properti (CEPAT) ---
                    // Ini masih O(V log V) karena sorting, tapi jauh lebih cepat dari DOM rebuild
                    displayProperties(propElId, graph.nodes, graph.edges);
                    
                    // --- KUNCI OPTIMASI 5: Update 2 sel matriks (INSTAN O(1)) ---
                    updateMatrixCell(graphId, selectedNodeForEdge.id, clickedNodeForEdge.id, newValue);

                    // Gambar ulang kanvas untuk menunjukkan sisi baru/hilang
                    drawCanvasOnly(graphId);

                } else {
                    // --- TIDAK ada perubahan sisi (Hanya Geser / Pilih / Batal Pilih) ---
                    // Panggil fungsi ringan (hanya gambar kanvas)
                    drawCanvasOnly(graphId);
                }
            });

            canvas.addEventListener('mouseout', (e) => {
                // Batalkan drag jika mouse keluar canvas
                const isG = (graphId === 'G');
                // Hanya reset jika sedang drag
                if (isG && isDraggingG) { 
                    draggedNodeG = null;
                    isDraggingG = false;
                    // drawCanvasOnly('G'); // Kita tidak perlu gambar ulang, biarkan loop animasi yg urus
                } else if (!isG && isDraggingH) {
                    draggedNodeH = null;
                    isDraggingH = false;
                    // drawCanvasOnly('H');
                }
            });
        }
        
        function createGraphSkeletons() {
            const n = parseInt(document.getElementById('nodeCount').value, 10);
            const shape = document.getElementById('layoutShape').value;
            
            if (isNaN(n) || n <= 0 || n > 200) {
                // Menggunakan dialog kustom (meskipun sederhana)
                alert("Masukkan jumlah simpul yang valid (1-200).");
                return;
            }
            
            // Reset state
            currentGraphG = { nodes: [], edges: {} };
            currentGraphH = { nodes: [], edges: {} };
            selectedNodeG = null;
            selectedNodeH = null;
            // BARU: Reset state drag
            draggedNodeG = null;
            isDraggingG = false;
            draggedNodeH = null;
            isDraggingH = false;
            
            const propsG = document.getElementById('propsG');
            const propsH = document.getElementById('propsH');
            
            propsG.innerHTML = '';
            propsH.innerHTML = '';
            ctxG.clearRect(0, 0, ctxG.canvas.width, ctxG.canvas.height);
            ctxH.clearRect(0, 0, ctxH.canvas.width, ctxH.canvas.height);
            document.getElementById('resultMessage').classList.add('hidden');

            const canvasWidth = ctxG.canvas.width;
            const canvasHeight = ctxG.canvas.height;
            const margin = 40;

            let layoutType = shape;
            if (layoutType === 'otomatis') {
                layoutType = (n <= 20) ? 'lingkaran' : 'grid';
            }

            for (let i = 0; i < n; i++) {
                let x, y;
                switch (layoutType) {
                    case 'lingkaran': {
                        const radius = Math.min(canvasWidth, canvasHeight) / 2 - margin;
                        const centerX = canvasWidth / 2;
                        const centerY = canvasHeight / 2;
                        const angle = (i / n) * 2 * Math.PI - (Math.PI / 2);
                        x = centerX + radius * Math.cos(angle);
                        y = centerY + radius * Math.sin(angle);
                        break;
                    }
                    case 'grid': {
                        const cols = Math.ceil(Math.sqrt(n * (canvasWidth / canvasHeight)));
                        const rows = Math.ceil(n / cols);
                        const xSpacing = (canvasWidth - 2 * margin) / (cols - 1 || 1);
                        const ySpacing = (canvasHeight - 2 * margin) / (rows - 1 || 1);
                        const row = Math.floor(i / cols);
                        const col = i % cols;
                        x = (n === 1) ? canvasWidth / 2 : margin + col * xSpacing;
                        y = (n === 1) ? canvasHeight / 2 : margin + row * ySpacing;
                        break;
                    }
                    case 'garis': {
                        const xSpacing = (canvasWidth - 2 * margin) / (n - 1 || 1);
                        const centerY = canvasHeight / 2;
                        x = (n === 1) ? canvasWidth / 2 : margin + i * xSpacing;
                        y = centerY;
                        break;
                    }
                    case 'spiral': {
                        const centerX = canvasWidth / 2;
                        const centerY = canvasHeight / 2;
                        const c = Math.min(canvasWidth, canvasHeight) / (2.2 * Math.sqrt(n));
                        const angle = i * 137.5 * (Math.PI / 180);
                        const radius = c * Math.sqrt(i + 1);
                        x = centerX + radius * Math.cos(angle);
                        y = centerY + radius * Math.sin(angle);
                        break;
                    }
                    case 'acak': {
                        x = margin + Math.random() * (canvasWidth - 2 * margin);
                        y = margin + Math.random() * (canvasHeight - 2 * margin);
                        break;
                    }
                }
                
                // --- PERBAIKAN: Menambahkan kembali kode yang hilang untuk membuat simpul ---
                currentGraphG.nodes.push({ id: 'u' + (i + 1), label: 'u' + (i + 1), x, y, degree: 0 });
                currentGraphH.nodes.push({ id: 'v' + (i + 1), label: 'v' + (i + 1), x, y, degree: 0 });
                // --- AKHIR PERBAIKAN ---
            }

            // --- PERBAIKAN: Panggil fungsi baru ---
            // 1. Gambar kanvas (RINGAN)
            drawNodes(ctxG, currentGraphG, null);
            drawNodes(ctxH, currentGraphH, null);
            
            // 2. Hitung properti & update teks (SEDANG)
            recalculateAllProperties('G');
            recalculateAllProperties('H');

            // 3. Render matriks (BERAT)
            // Ini satu-satunya tempat kita membangun seluruh tabel HTML
            updateAdjacencyMatrix('G');
            updateAdjacencyMatrix('H');
        }

        // --- ============================================ ---
        // --- ALGORITMA PENGECEKAN ISOMORFISME PENUH ---
        // --- ============================================ ---

        function buildAdjacencySet(graph) {
            const adj = new Map(graph.nodes.map(n => [n.id, new Set()]));
            for (const edgeKey in graph.edges) {
                if (graph.edges[edgeKey]) {
                    const [id1, id2] = edgeKey.split('-');
                    adj.get(id1).add(id2);
                    adj.get(id2).add(id1);
                }
            }
            return adj;
        }

        // Fungsi ini SANGAT PENTING untuk "Slide 2" Anda
        function buildAdjacencyMatrix(nodes, edges) {
            // Urutkan simpul berdasarkan ID numerik (u1, u2, ... u10)
            const sortedNodes = [...nodes].sort((a, b) => {
                // Tambahkan pengecekan jika id tidak ada atau formatnya salah
                const id_a_match = a.id.match(/\d+/);
                const id_b_match = b.id.match(/\d+/);
                if (!id_a_match) return 1;
                if (!id_b_match) return -1;

                const id_a = parseInt(id_a_match[0]);
                const id_b = parseInt(id_b_match[0]);
                return id_a - id_b;
            });

            const n = sortedNodes.length;
            const labels = sortedNodes.map(node => node.label);
            const nodeIdToIndex = new Map(sortedNodes.map((node, i) => [node.id, i]));
            const matrix = Array(n).fill(0).map(() => Array(n).fill(0));

            for (const edgeKey in edges) {
                if (edges[edgeKey]) {
                    const [id1, id2] = edgeKey.split('-');
                    const i = nodeIdToIndex.get(id1);
                    const j = nodeIdToIndex.get(id2);
                    if (i !== undefined && j !== undefined) {
                        matrix[i][j] = 1;
                        matrix[j][i] = 1;
                    }
                }
            }
            // Sesuai permintaan Anda:
            // matrix[i][i] akan selalu 0 karena inisialisasi
            // matrix[i][j] akan 1 jika terhubung (nyambung)
            
            // --- KUNCI OPTIMASI 1 (Tambahan) ---
            // Kembalikan juga map-nya
            return { matrix, labels, nodeIdToIndex };
        }

        // Fungsi ini SANGAT PENTING untuk "Slide 2" Anda
        function formatMatrixAsHTML(matrixData) {
            const { matrix, labels } = matrixData;
            // --- KUNCI OPTIMASI 2 (Tambahan) ---
            // Beri ID pada tabel agar mudah ditemukan
            const tableId = (labels.length > 0 && labels[0].startsWith('u')) ? 'matrixTableG' : 'matrixTableH';
            let html = `<table class="matrix-table" id="${tableId}">`;
            
            // Buat header kolom (u1, u2, ...)
            html += '<thead><tr><th>&nbsp;</th>'; // Pojok kiri atas
            labels.forEach(label => {
                html += `<th>${label}</th>`;
            });
            html += '</tr></thead>';

            // Buat baris
            html += '<tbody>';
            matrix.forEach((row, i) => {
                html += `<tr><th>${labels[i]}</th>`; // Header baris
                row.forEach(cell => {
                    html += `<td>${cell}</td>`; // Nilai 0 atau 1
                });
                html += '</tr>';
            });
            html += '</tbody></table>';
            return html;
        }

        function checkFullIsomorphism(graphG, graphH) {
            const adjG = buildAdjacencySet(graphG);
            const adjH = buildAdjacencySet(graphH);

            const gNodes = [...graphG.nodes].sort((a, b) => b.degree - a.degree);
            const hNodes = [...graphH.nodes].sort((a, b) => b.degree - a.degree);

            const mapping = new Map();
            const hNodesUsed = new Set();

            function tryMap(gNodeIndex) {
                if (gNodeIndex === gNodes.length) {
                    return true;
                }
                const gNode = gNodes[gNodeIndex];
                for (const hNode of hNodes) {
                    if (hNodesUsed.has(hNode.id)) {
                        continue;
                    }
                    if (gNode.degree !== hNode.degree) {
                        continue;
                    }
                    let isConsistent = true;
                    for (let i = 0; i < gNodeIndex; i++) {
                        const prevGNode = gNodes[i];
                        const mappedHNodeId = mapping.get(prevGNode.id);
                        const gIsAdjacent = adjG.get(gNode.id).has(prevGNode.id);
                        const hIsAdjacent = adjH.get(hNode.id).has(mappedHNodeId);
                        if (gIsAdjacent !== hIsAdjacent) {
                            isConsistent = false;
                            break;
                        }
                    }
                    if (isConsistent) {
                        mapping.set(gNode.id, hNode.id);
                        hNodesUsed.add(hNode.id);
                        if (tryMap(gNodeIndex + 1)) {
                            return true;
                        }
                        hNodesUsed.delete(hNode.id);
                        mapping.delete(gNode.id);
                    }
                }
                return false;
            }

            const isIsomorphic = tryMap(0);
            if (isIsomorphic) {
                return mapping;
            } else {
                return false;
            }
        }

        // --- Event Listener Utama ---
        document.addEventListener('DOMContentLoaded', () => {
            const canvasG = document.getElementById('graphGCanvas');
            const canvasH = document.getElementById('graphHCanvas');
            ctxG = canvasG.getContext('2d');
            ctxH = canvasH.getContext('2d');
            
            // --- DIPERBARUI: Menggunakan setupCanvasInteractions ---
            setupCanvasInteractions('G', canvasG);
            setupCanvasInteractions('H', canvasH);
            
            document.getElementById('createGraphButton').addEventListener('click', createGraphSkeletons);
            createGraphSkeletons();

            // --- BARU: Event listener untuk tombol toggle drag ---
            const toggleDragBtn = document.getElementById('toggleDragButton');
            toggleDragBtn.addEventListener('click', () => {
                isDragModeEnabled = !isDragModeEnabled;
                if (isDragModeEnabled) {
                    toggleDragBtn.textContent = 'Mode Geser: ON';
                    toggleDragBtn.classList.remove('bg-red-600', 'hover:bg-red-700', 'active:bg-red-800'); // Hapus kelas OFF
                    toggleDragBtn.classList.add('bg-blue-600', 'hover:bg-blue-700', 'active:bg-blue-800'); // Tambah kelas ON
                } else {
                    toggleDragBtn.textContent = 'Mode Geser: OFF';
                    toggleDragBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'active:bg-blue-800'); // Hapus kelas ON
                    toggleDragBtn.classList.add('bg-red-600', 'hover:bg-red-700', 'active:bg-red-800'); // Tambah kelas OFF
                    
                    // --- PENTING: Batalkan drag yg sedang berlangsung jika dinonaktifkan ---
                    isDraggingG = false;
                    draggedNodeG = null;
                    isDraggingH = false;
                    draggedNodeH = null;

                    // Batalkan juga pemilihan simpul
                    selectedNodeG = null;
                    selectedNodeH = null;
                    drawCanvasOnly('G');
                    drawCanvasOnly('H');
                }
            });

            // --- BARU: Mulai loop animasi global ---
            animationLoop();

            document.getElementById('checkIsomorphismButton').addEventListener('click', () => {
                const resultEl = document.getElementById('resultMessage');
                const loadingEl = document.getElementById('loadingIndicator');
                resultEl.className = '';
                resultEl.classList.add('hidden');
                loadingEl.classList.add('hidden');
                
                let seqG, seqH;
                let messages = [];
                let isIsomorphicCandidate = true;

                // --- 1. Syarat Perlu Cepat ---
                
                if (currentGraphG.nodes.length !== currentGraphH.nodes.length) {
                    messages.push(`Jumlah simpul tidak sama (G: ${currentGraphG.nodes.length}, H: ${currentGraphH.nodes.length}).`);
                    isIsomorphicCandidate = false;
                } else {
                    messages.push(`Jumlah simpul SAMA (${currentGraphG.nodes.length}).`);
                }

                const edgeCountG = Object.values(currentGraphG.edges).filter(Boolean).length;
                const edgeCountH = Object.values(currentGraphH.edges).filter(Boolean).length;
                if (edgeCountG !== edgeCountH) {
                    messages.push(`Jumlah sisi tidak sama (G: ${edgeCountG}, H: ${edgeCountH}).`);
                    isIsomorphicCandidate = false;
                } else {
                    messages.push(`Jumlah sisi SAMA (${edgeCountG}).`);
                }

                seqG = getDegreeSequence(currentGraphG.nodes);
                seqH = getDegreeSequence(currentGraphH.nodes);
                const strSeqG = JSON.stringify(seqG);
                const strSeqH = JSON.stringify(seqH);

                if (strSeqG !== strSeqH) {
                    messages.push(`Urutan derajat TIDAK SAMA.`);
                    messages.push(`Graf G: [${seqG.join(', ')}]`);
                    messages.push(`Graf H: [${seqH.join(', ')}]`);
                    isIsomorphicCandidate = false;
                } else {
                    messages.push(`Urutan derajat SAMA ([${seqG.join(', ')}]).`);
                }

                // --- 2. Kesimpulan ---

                if (!isIsomorphicCandidate) {
                    resultEl.innerHTML = `<strong>Kesimpulan:</strong> Kedua graf <strong>PASTI TIDAK</strong> isomorfik karena salah satu syarat perlu tidak terpenuhi.`;
                    resultEl.classList.add('result-error');
                    resultEl.innerHTML += `<ul class="list-disc list-inside text-left w-fit mx-auto mt-2"><li>${messages.join('</li><li>')}</li></ul>`;
                    resultEl.classList.remove('hidden');
                } else {
                    const n = currentGraphG.nodes.length;

                    if (n > FULL_CHECK_LIMIT) {
                        resultEl.innerHTML = `<strong>Kesimpulan:</strong> Kedua graf ... <strong>MUNGKIN ISOMORFIK</strong>.
                            <br><small class="font-normal">(Pengecekan penuh tidak dijalankan karena jumlah simpul > ${FULL_CHECK_LIMIT}. Pengecekan akan terlalu lambat.)</small>`;
                        resultEl.classList.add('result-warning');
                        resultEl.innerHTML += `<ul class="list-disc list-inside text-left w-fit mx-auto mt-2"><li>${messages.join('</li><li>')}</li></ul>`;
                        resultEl.classList.remove('hidden');
                    
                    } else {
                        loadingEl.classList.remove('hidden');
                        
                        setTimeout(() => {
                            const isomorphismResult = checkFullIsomorphism(currentGraphG, currentGraphH);
                            loadingEl.classList.add('hidden');

                            if (isomorphismResult) {
                                let mappingString = '<p class="text-sm font-normal mt-2">Pemetaan yang ditemukan (f: G → H):</p><ul class="text-xs list-disc list-inside text-left w-fit mx-auto">';
                                
                                const gNodesSorted = [...currentGraphG.nodes].sort((a, b) => {
                                    return parseInt(a.id.substring(1)) - parseInt(b.id.substring(1));
                                });
                                const hNodeMapById = new Map(currentGraphH.nodes.map(n => [n.id, n]));

                                for (const gNode of gNodesSorted) {
                                    const hNodeId = isomorphismResult.get(gNode.id);
                                    const hNodeLabel = hNodeMapById.get(hNodeId)?.label || hNodeId;
                                    mappingString += `<li>f(${gNode.label}) = ${hNodeLabel}</li>`;
                                }
                                mappingString += '</ul>';

                                let matrixString = '<h4 class="text-md font-medium mt-4">Pembuktian Akhir dengan Matriks</h4>';
                                matrixString += '<div class="grid grid-cols-1 xl:grid-cols-2 gap-4 mt-2 overflow-x-auto p-2">';

                                const matrixG_Data = buildAdjacencyMatrix(gNodesSorted, currentGraphG.edges);
                                const matrixG_HTML = formatMatrixAsHTML(matrixG_Data);
                                matrixString += `<div><p class="text-sm font-medium mb-1">Matriks G (A<sub>G</sub>)</p>${matrixG_HTML}</div>`;

                                const hNodesReordered = gNodesSorted.map(gNode => {
                                    const hNodeId = isomorphismResult.get(gNode.id);
                                    return hNodeMapById.get(hNodeId);
                                });
                                const matrixH_Data = buildAdjacencyMatrix(hNodesReordered, currentGraphH.edges);
                                const matrixH_HTML = formatMatrixAsHTML(matrixH_Data);
                                matrixString += `<div><p class="text-sm font-medium mb-1">Matriks H (A<sub>H</sub>, diurutkan f(G))</p>${matrixH_HTML}</div>`;
                                
                                matrixString += '</div>';
                                matrixString += '<p class="text-xs text-gray-600 mt-2">Jika kedua matriks identik, maka terbukti f menjaga ketetanggaan (sisi) dan graf adalah isomorfik.</p>';

                                resultEl.innerHTML = `<strong>Kesimpulan:</strong> Kedua graf <strong>PASTI ISOMORFIK</strong>.
                                    <br><small class="font-normal">(Pengecekan penuh (n=${n}) berhasil menemukan pemetaan.)</small>`;
                                resultEl.classList.add('result-success');
                                resultEl.innerHTML += mappingString;
                                // Kita tidak perlu lagi menampilkan matriks di sini, karena sudah ada di atas
                                // resultEl.innerHTML += matrixString; 

                            } else {
                                resultEl.innerHTML = `<strong>Kesimpulan:</strong> Kedua graf <strong>TIDAK ISOMORFIK</strong>.
                                    <br><small class="font-normal">(Meskipun syarat perlu terpenuhi, pengecekan penuh (n=${n}) gagal menemukan pemetaan.)</small>`;
                                resultEl.classList.add('result-error');
                            }
                            resultEl.innerHTML += `<ul class="list-disc list-inside text-left w-fit mx-auto mt-2"><li>${messages.join('</li><li>')}</li></ul>`;
                            resultEl.classList.remove('hidden');
                        }, 0);
                    }
                }
            });
        });

    </script>
</body>
</html>
